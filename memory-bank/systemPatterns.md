# System Patterns: Smart Ledger Backend (Node.js)

**Architecture:**
- **Web Server:** Node.js with Express.js framework.
- **API Endpoints:** RESTful API endpoints for interacting with the ledger (e.g., `/api/health`, and entity-specific endpoints like `/api/merchants`, `/api/accounts`).
- **Database:** PostgreSQL.
- **ORM/Migration Tool:** Prisma for schema management, migrations, and database access (via Prisma Client).
- **Modularity:** The application is structured into:
    - `prisma`: Contains `schema.prisma` (schema definition) and is used by Prisma CLI. Prisma also generates **Prisma Models** (types for database entities) into `node_modules/.prisma/client`, which serve as the source of truth for database interactions.
    - `migrations`: Contains SQL migration files generated by Prisma.
    - `config`: Application configuration.
    - `services`: Shared services, primarily `prisma.ts` (exporting Prisma Client instance).
    - `db_models`: (Potentially less used if Prisma schema is the primary source of truth, but could hold complex raw queries or view definitions).
    - `src/server/api_models`: Contains **API Models** (e.g., `merchant.types.ts`). These define Data Transfer Objects (DTOs) for HTTP request/response bodies and validation schemas.
    - `src/server/domain_models`: Contains **Domain Models** (e.g., `merchant.types.ts`). These represent core business entities and logic, independent of API or database specifics.
    - `server/routes`: Defines API routes and maps them to handlers. Organized by entity (e.g., `server/routes/merchant/`, `server/routes/account/`).
    - `server/core`: Contains the core business logic (services) for each feature. Organized by entity (e.g., `server/core/merchant/`, `server/core/account/`).
    - `utils`: Common utility functions.

**General Data Flow (Example for a typical entity):**
1.  HTTP request hits an API endpoint (e.g., `POST /api/<entity-name>`).
2.  The route handler in `src/server/routes/<entity-name>/index.js` receives the request.
3.  The handler calls a service function in `src/server/core/<entity-name>/index.js`, passing validated request data.
4.  The core service function implements the business logic:
    - Interacts with Prisma Client (from `src/services/prisma.js`) to perform database operations (e.g., `prisma.<entityModel>.create()`).
    - May involve related entities or specific business rules.
5.  The core service function returns a result to the route handler.
6.  The route handler sends an HTTP JSON response.
    *Specific data flow examples for entities like "Sales" or "Transactions" will be detailed in their respective `memory-bank/entities/` documents as they are developed.*

**Key Design Patterns:**
- **Service Layer:** Business logic is encapsulated in `core` modules, separating it from route handling.
- **Repository/Data Access Layer:**
    - Prisma Client (exported from `services/prisma.ts`) provides data access methods.
    - Helper functions for common database operations (e.g., `findUniqueOrThrow`) are available in `src/services/databaseHelpers.ts`.
    - Conventions:
        - Use `select` to fetch only necessary fields.
        - Use interactive transactions (`prisma.$transaction`) for atomic multi-write operations.
        - Handle Prisma-specific error codes (`error.code`) for precise error responses.
- **Configuration Management:** Environment variables (`.env` file, loaded by `dotenv`) are used for sensitive or environment-specific settings, managed via `src/config/index.ts`. `DATABASE_URL` in `.env` is crucial for Prisma.
- **Connection Pooling:** Handled internally by Prisma Client.
- **Asynchronous Operations:** Extensive use of `async/await` for non-blocking I/O (database calls, etc.).
- **Centralized Routing:** A main router (`src/server/routes/index.ts`) aggregates feature-specific routers.
- **Logging:** (Refer to `memory-bank/techContext.md` for detailed logging setup with Winston, Request IDs, and Prisma integration).
- **Error Handling:**
    - **Comprehensive Error Hierarchy:** A base `AppError` class (`src/errors/AppError.ts`) with several domain-specific error categories:
        - `DatabaseError`: For database-related errors (connection, query, transaction, entity not found)
        - `BusinessLogicError`: For business rule violations (duplicates, state errors, balance errors)
        - `ExternalServiceError`: For integration issues (service unavailable, timeout, response errors)
        - `SystemError`: For application-level issues (configuration, file system, unexpected errors)
        - Each module also has specific error classes (e.g., `TransactionNotFoundError`, `BalanceError`) that extend these domain categories
    - Each `AppError` instance includes:
        - `message`: Human-readable error message
        - `statusCode`: HTTP status code for the response
        - `errorCode`: A unique application-specific error code string following the pattern `ERR_MODULE_TYPE`
        - `isOperational`: Boolean indicating if the error is operational (vs. a programmer bug)
        - `details`: Additional structured information about the error
        - `cause`: Optional underlying error that caused this error (supports error chaining)
    - **Error Utilities:**
        - `withDetails()` method to add context without creating new errors
        - Error cause chaining to preserve the original error stack trace
        - Centralized imports through `src/errors/index.ts`
    - **Global Error Handler:** Enhanced error handling middleware in `src/app.ts`:
        - Captures request context (requestId) for traceability
        - Logs errors with contextual information (URL, method, cause)
        - Returns standardized error responses with code, message, and details
        - Environment-specific behavior (includes stack traces in development)
    - **Core Logic:** Core service modules throw specific error types for different error conditions, providing detailed context in the `details` property.
- **API Documentation:** Swagger UI served at `/api-docs`, generated from JSDoc comments in route files using `swagger-jsdoc` and `swagger-ui-express`.
- **Producer-Consumer Pattern (Recon Engine):**
    - **Process Tracker (`src/server/core/process-tracker`):** A database-backed queue (`ProcessTracker` model) manages tasks for asynchronous processing. Core functions include `createTask`, `getNextPendingTask`, `updateTaskStatus`.
    - **Producer (`src/server/core/staging-entry`):** The `createStagingEntry` function acts as a producer. Upon successful creation of a `StagingEntry`, it enqueues a `PROCESS_STAGING_ENTRY` task into the Process Tracker.
    - **Consumer (`src/server/core/recon-engine/consumer.js`):** A separate process (run by `src/recon-engine-runner.js`) that polls the Process Tracker for pending `PROCESS_STAGING_ENTRY` tasks.
        - For each task, it fetches the corresponding `StagingEntry`.
        - It calls `reconEngine.processStagingEntryWithRecon(stagingEntry, merchantId)`.
        - Based on the outcome (success or error) of `processStagingEntryWithRecon`, it updates the `ProcessTracker` task status to `COMPLETED` or `FAILED`.
    - **Manual Trigger API (`POST /api/recon-engine/trigger`):** Provides on-demand processing capability:
        - Accepts optional timeout parameter (1000-3600000ms)
        - Calls `consumer.processTasksForDuration()` to process tasks for specified duration
        - Returns processing statistics: processed, succeeded, failed counts and duration
        - Useful for testing, debugging, and controlled processing windows
    - This pattern decouples the initial data ingestion from the more complex reconciliation and transaction creation process.

- **Recon Engine Core (`src/server/core/recon-engine/engine.js`):**
    - `generateTransactionEntriesFromStaging(stagingEntry, merchantId)`: Applies `ReconRule`s to a `StagingEntry` to derive data for an actual entry (status `POSTED`) and an expected contra-entry (status `EXPECTED`). Throws `NoReconRuleFoundError` if no rule applies.
    - `processStagingEntryWithRecon(stagingEntry, merchantId)`:
        - Orchestrates the reconciliation for a single `StagingEntry`.
        - Calls `generateTransactionEntriesFromStaging`.
        - Prepares `transactionShellData`.
        - Calls `transactionCore.createTransactionInternal` to atomically create the `Transaction` and its two `Entry` records.
        - If all steps succeed, it updates the `StagingEntry` status to `PROCESSED`.
        - If `NoReconRuleFoundError` or `BalanceError` (from `createTransactionInternal`) occurs, or any other error during the process, it updates the `StagingEntry` status to `NEEDS_MANUAL_REVIEW` and then re-throws the error to be handled by the consumer (which will update the `ProcessTracker` task).
    - This module encapsulates the primary business logic for reconciliation.

- **Atomic Operations (`prisma.$transaction`):**
    - For operations requiring multiple database writes that must succeed or fail together (e.g., creating a `Transaction` and its associated `Entry` records), Prisma's interactive transactions (`prisma.$transaction(async (tx) => { ... })`) are used.
    - This ensures data consistency by rolling back all operations within the transaction block if any single operation fails.
    - Example: `src/server/core/transaction/index.js` uses this pattern in `createTransactionInternal` to atomically create a transaction and its two balanced entries.

- **Balance Calculation Pattern:**
    - Account balances are calculated dynamically by combining:
      1. The account's `initial_balance` (stored in the database)
      2. Sum of entries from the Entry table based on status (POSTED, EXPECTED)
    - Three balance types are calculated:
      - **Posted Balance**: Initial balance + settled entries
      - **Pending Balance**: Initial balance + all entries (settled + expected)
      - **Available Balance**: Initial balance + posted debits - pending credits (for DEBIT_NORMAL)
    - Balance formulas vary based on `account_type` (DEBIT_NORMAL vs CREDIT_NORMAL)
    - This pattern ensures consistency and avoids complex balance update triggers
