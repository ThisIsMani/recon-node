# System Patterns: Smart Ledger Backend (Node.js)

**Architecture:**
- **Web Server:** Node.js with Express.js framework.
- **API Endpoints:** RESTful API endpoints for interacting with the ledger (e.g., `/api/health`, and entity-specific endpoints like `/api/merchants`, `/api/accounts`).
- **Database:** PostgreSQL.
- **ORM/Migration Tool:** Prisma for schema management, migrations, and database access (via Prisma Client).
- **Modularity:** The application is structured into:
    - `prisma`: Contains `schema.prisma` (schema definition) and is used by Prisma CLI.
    - `migrations`: Contains SQL migration files generated by Prisma.
    - `config`: Application configuration.
    - `services`: Shared services, primarily `prisma.js` (exporting Prisma Client instance).
    - `db_models`: (Potentially less used if Prisma schema is the primary source of truth, but could hold complex raw queries or view definitions).
    - `api_models`: Intended for request/response data structure definitions or validation schemas.
    - `server/routes`: Defines API routes and maps them to handlers. Organized by entity (e.g., `server/routes/merchant/`, `server/routes/account/`).
    - `server/core`: Contains the core business logic (services) for each feature. Organized by entity (e.g., `server/core/merchant/`, `server/core/account/`).
    - `utils`: Common utility functions.

**General Data Flow (Example for a typical entity):**
1.  HTTP request hits an API endpoint (e.g., `POST /api/<entity-name>`).
2.  The route handler in `src/server/routes/<entity-name>/index.js` receives the request.
3.  The handler calls a service function in `src/server/core/<entity-name>/index.js`, passing validated request data.
4.  The core service function implements the business logic:
    - Interacts with Prisma Client (from `src/services/prisma.js`) to perform database operations (e.g., `prisma.<entityModel>.create()`).
    - May involve related entities or specific business rules.
5.  The core service function returns a result to the route handler.
6.  The route handler sends an HTTP JSON response.
    *Specific data flow examples for entities like "Sales" or "Transactions" will be detailed in their respective `memory-bank/entities/` documents as they are developed.*

**Key Design Patterns:**
- **Service Layer:** Business logic is encapsulated in `core` modules, separating it from route handling.
- **Repository/Data Access Layer:** Prisma Client (exported from `services/prisma.js`) provides data access methods.
- **Configuration Management:** Environment variables (`.env` file, loaded by `dotenv`) are used for sensitive or environment-specific settings, managed via `src/config/index.js`. `DATABASE_URL` in `.env` is crucial for Prisma.
- **Connection Pooling:** Handled internally by Prisma Client.
- **Asynchronous Operations:** Extensive use of `async/await` for non-blocking I/O (database calls, etc.).
- **Centralized Routing:** A main router (`src/server/routes/index.js`) aggregates feature-specific routers.
- **Logging:** A simple logger service (`src/services/logger.js`) wraps `console` methods and allows conditional logging (e.g., disabled during `NODE_ENV=test`). This is used throughout the application for consistent logging.
- **Error Handling:** Basic centralized error handling middleware in `src/app.js`. Prisma-specific errors (e.g., unique constraint violations) are handled in core logic. Custom errors like `NoReconRuleFoundError` and `BalanceError` are used for specific business logic failures.
- **API Documentation:** Swagger UI served at `/api-docs`, generated from JSDoc comments in route files using `swagger-jsdoc` and `swagger-ui-express`.
- **Producer-Consumer Pattern (Recon Engine):**
    - **Process Tracker (`src/server/core/process-tracker`):** A database-backed queue (`ProcessTracker` model) manages tasks for asynchronous processing. Core functions include `createTask`, `getNextPendingTask`, `updateTaskStatus`.
    - **Producer (`src/server/core/staging-entry`):** The `createStagingEntry` function acts as a producer. Upon successful creation of a `StagingEntry`, it enqueues a `PROCESS_STAGING_ENTRY` task into the Process Tracker.
    - **Consumer (`src/server/core/recon-engine/consumer.js`):** A separate process (run by `src/recon-engine-runner.js`) that polls the Process Tracker for pending `PROCESS_STAGING_ENTRY` tasks.
        - For each task, it fetches the corresponding `StagingEntry`.
        - It calls `reconEngine.processStagingEntryWithRecon(stagingEntry, merchantId)`.
        - Based on the outcome (success or error) of `processStagingEntryWithRecon`, it updates the `ProcessTracker` task status to `COMPLETED` or `FAILED`.
    - This pattern decouples the initial data ingestion from the more complex reconciliation and transaction creation process.

- **Recon Engine Core (`src/server/core/recon-engine/engine.js`):**
    - `generateTransactionEntriesFromStaging(stagingEntry, merchantId)`: Applies `ReconRule`s to a `StagingEntry` to derive data for an actual entry (status `POSTED`) and an expected contra-entry (status `EXPECTED`). Throws `NoReconRuleFoundError` if no rule applies.
    - `processStagingEntryWithRecon(stagingEntry, merchantId)`:
        - Orchestrates the reconciliation for a single `StagingEntry`.
        - Calls `generateTransactionEntriesFromStaging`.
        - Prepares `transactionShellData`.
        - Calls `transactionCore.createTransactionInternal` to atomically create the `Transaction` and its two `Entry` records.
        - If all steps succeed, it updates the `StagingEntry` status to `PROCESSED`.
        - If `NoReconRuleFoundError` or `BalanceError` (from `createTransactionInternal`) occurs, or any other error during the process, it updates the `StagingEntry` status to `NEEDS_MANUAL_REVIEW` and then re-throws the error to be handled by the consumer (which will update the `ProcessTracker` task).
    - This module encapsulates the primary business logic for reconciliation.

- **Atomic Operations (`prisma.$transaction`):**
    - For operations requiring multiple database writes that must succeed or fail together (e.g., creating a `Transaction` and its associated `Entry` records), Prisma's interactive transactions (`prisma.$transaction(async (tx) => { ... })`) are used.
    - This ensures data consistency by rolling back all operations within the transaction block if any single operation fails.
    - Example: `src/server/core/transaction/index.js` uses this pattern in `createTransactionInternal` to atomically create a transaction and its two balanced entries.
