# System Patterns: Smart Ledger Backend (Node.js)

**Architecture:**
- **Web Server:** Node.js with Express.js framework.
- **API Endpoints:** RESTful API endpoints for interacting with the ledger (e.g., `/api/health`, and entity-specific endpoints like `/api/merchants`, `/api/accounts`).
- **Database:** PostgreSQL.
- **ORM/Migration Tool:** Prisma for schema management, migrations, and database access (via Prisma Client).
- **Modularity:** The application is structured into:
    - `prisma`: Contains `schema.prisma` (schema definition) and is used by Prisma CLI. Prisma also generates **Prisma Models** (types for database entities) into `node_modules/.prisma/client`, which serve as the source of truth for database interactions.
    - `migrations`: Contains SQL migration files generated by Prisma.
    - `config`: Application configuration.
    - `services`: Shared services, primarily `prisma.ts` (exporting Prisma Client instance).
    - `db_models`: (Potentially less used if Prisma schema is the primary source of truth, but could hold complex raw queries or view definitions).
    - `src/server/api_models`: Contains **API Models** (e.g., `merchant.types.ts`). These define Data Transfer Objects (DTOs) for HTTP request/response bodies and validation schemas.
    - `src/server/domain_models`: Contains **Domain Models** (e.g., `merchant.types.ts`). These represent core business entities and logic, independent of API or database specifics.
    - `server/routes`: Defines API routes and maps them to handlers. Organized by entity (e.g., `server/routes/merchant/`, `server/routes/account/`).
    - `server/core`: Contains the core business logic (services) for each feature. Organized by entity (e.g., `server/core/merchant/`, `server/core/account/`).
    - `utils`: Common utility functions.

**General Data Flow (Example for a typical entity):**
1.  HTTP request hits an API endpoint (e.g., `POST /api/<entity-name>`).
2.  The route handler in `src/server/routes/<entity-name>/index.js` receives the request.
3.  The handler calls a service function in `src/server/core/<entity-name>/index.js`, passing validated request data.
4.  The core service function implements the business logic:
    - Interacts with Prisma Client (from `src/services/prisma.js`) to perform database operations (e.g., `prisma.<entityModel>.create()`).
    - May involve related entities or specific business rules.
5.  The core service function returns a result to the route handler.
6.  The route handler sends an HTTP JSON response.
    *Specific data flow examples for entities like "Sales" or "Transactions" will be detailed in their respective `memory-bank/entities/` documents as they are developed.*

**Key Design Patterns:**
- **Service Layer:** Business logic is encapsulated in `core` modules, separating it from route handling.
- **Repository/Data Access Layer:**
    - Prisma Client (exported from `services/prisma.ts`) provides data access methods.
    - Helper functions for common database operations (e.g., `findUniqueOrThrow`) are available in `src/services/databaseHelpers.ts`.
    - Conventions:
        - Use `select` to fetch only necessary fields.
        - Use interactive transactions (`prisma.$transaction`) for atomic multi-write operations.
        - Handle Prisma-specific error codes (`error.code`) for precise error responses.
- **Configuration Management:** Environment variables (`.env` file, loaded by `dotenv`) are used for sensitive or environment-specific settings, managed via `src/config/index.ts`. `DATABASE_URL` in `.env` is crucial for Prisma.
- **Connection Pooling:** Handled internally by Prisma Client.
- **Asynchronous Operations:** Extensive use of `async/await` for non-blocking I/O (database calls, etc.).
- **Centralized Routing:** A main router (`src/server/routes/index.ts`) aggregates feature-specific routers.
- **Logging:** (Refer to `memory-bank/techContext.md` for detailed logging setup with Winston, Request IDs, and Prisma integration).
- **Error Handling:**
    - **Custom Error Hierarchy:** A base `AppError` class (`src/errors/AppError.ts`) is used for standardized application errors. Specific error classes (e.g., `NotFoundError`, `ValidationError`, `InternalServerError`, `BalanceError`, `NoReconRuleFoundError`) extend `AppError`.
    - Each `AppError` instance includes:
        - `message`: Human-readable error message.
        - `statusCode`: HTTP status code for the response.
        - `errorCode`: A unique application-specific error code string (e.g., `ERR_NOT_FOUND`).
        - `isOperational`: Boolean indicating if the error is operational (vs. a programmer bug).
        - `details` (optional): Additional structured information about the error.
    - **Global Error Handler:** Centralized error handling middleware in `src/app.ts` catches errors.
        - If the error is an `instanceof AppError`, it uses `statusCode`, `errorCode`, `message`, and `details` to formulate a structured JSON response.
        - For other errors, it responds with a generic 500 error and `ERR_UNHANDLED` code.
    - **Core Logic:** Core service modules are refactored to throw instances of `AppError` subclasses for known error conditions (e.g., validation failures, resource not found).
- **API Documentation:** Swagger UI served at `/api-docs`, generated from JSDoc comments in route files using `swagger-jsdoc` and `swagger-ui-express`.
- **Producer-Consumer Pattern (Recon Engine):**
    - **Process Tracker (`src/server/core/process-tracker`):** A database-backed queue (`ProcessTracker` model) manages tasks for asynchronous processing. Core functions include `createTask`, `getNextPendingTask`, `updateTaskStatus`.
    - **Producer (`src/server/core/staging-entry`):** The `createStagingEntry` function acts as a producer. Upon successful creation of a `StagingEntry`, it enqueues a `PROCESS_STAGING_ENTRY` task into the Process Tracker.
    - **Consumer (`src/server/core/recon-engine/consumer.js`):** A separate process (run by `src/recon-engine-runner.js`) that polls the Process Tracker for pending `PROCESS_STAGING_ENTRY` tasks.
        - For each task, it fetches the corresponding `StagingEntry`.
        - It calls `reconEngine.processStagingEntryWithRecon(stagingEntry, merchantId)`.
        - Based on the outcome (success or error) of `processStagingEntryWithRecon`, it updates the `ProcessTracker` task status to `COMPLETED` or `FAILED`.
    - This pattern decouples the initial data ingestion from the more complex reconciliation and transaction creation process.

- **Recon Engine Core (`src/server/core/recon-engine/engine.js`):**
    - `generateTransactionEntriesFromStaging(stagingEntry, merchantId)`: Applies `ReconRule`s to a `StagingEntry` to derive data for an actual entry (status `POSTED`) and an expected contra-entry (status `EXPECTED`). Throws `NoReconRuleFoundError` if no rule applies.
    - `processStagingEntryWithRecon(stagingEntry, merchantId)`:
        - Orchestrates the reconciliation for a single `StagingEntry`.
        - Calls `generateTransactionEntriesFromStaging`.
        - Prepares `transactionShellData`.
        - Calls `transactionCore.createTransactionInternal` to atomically create the `Transaction` and its two `Entry` records.
        - If all steps succeed, it updates the `StagingEntry` status to `PROCESSED`.
        - If `NoReconRuleFoundError` or `BalanceError` (from `createTransactionInternal`) occurs, or any other error during the process, it updates the `StagingEntry` status to `NEEDS_MANUAL_REVIEW` and then re-throws the error to be handled by the consumer (which will update the `ProcessTracker` task).
    - This module encapsulates the primary business logic for reconciliation.

- **Atomic Operations (`prisma.$transaction`):**
    - For operations requiring multiple database writes that must succeed or fail together (e.g., creating a `Transaction` and its associated `Entry` records), Prisma's interactive transactions (`prisma.$transaction(async (tx) => { ... })`) are used.
    - This ensures data consistency by rolling back all operations within the transaction block if any single operation fails.
    - Example: `src/server/core/transaction/index.js` uses this pattern in `createTransactionInternal` to atomically create a transaction and its two balanced entries.
